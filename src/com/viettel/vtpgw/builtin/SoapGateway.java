package com.viettel.vtpgw.builtin;

import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeoutException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import com.viettel.vtpgw.http.HttpServerRequestWrapper;
import com.viettel.vtpgw.model.Endpoint;
import com.viettel.vtpgw.model.HttpService;
import com.viettel.vtpgw.support.HttpClientHelper;
import com.viettel.vtpgw.support.soap.KxmlSoapExtractor;
import com.viettel.vtpgw.util.JedisUtil;
import com.viettel.vtpgw.util.LogUtil;
import com.viettel.vtpgw.util.Utils;

import io.vertx.core.Future;
import io.vertx.core.Handler;
import io.vertx.core.Vertx;
import io.vertx.core.buffer.Buffer;
import io.vertx.core.http.HttpClient;
import io.vertx.core.http.HttpClientRequest;
import io.vertx.core.http.HttpHeaders;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.core.impl.StringEscapeUtils;
import io.vertx.core.json.JsonObject;
import redis.clients.jedis.JedisCluster;

public class SoapGateway extends HttpGateway {

    //public static final String CACHE_SOAP_JEDIS_CHANNEL_1 = "CacheGW-Channel-Soap-1";
    public static final String CACHE_EVENT_BUS_CHANNEL_SOAP = "EventBus-Soap";
    public static final String CACHE_EVENT_BUS_CHANNEL_CLEAR = "EventBus-Clear";

    private static final Pattern LOCATION = Pattern.compile("\\s(?:schemaLocation|location)\\s*=\\s*[\"']([^\"'\\?]*)");
    static Logger logger = LogManager.getLogger(SoapGateway.class);
    static Logger loggerIO = LogManager.getLogger("InputOutput");

    static Logger loggerGWIO = LogManager.getLogger("Gateway-Out");

    static SoapGateway singleton;

    JedisCluster jedis; // = JedisUtil.getJedisCluster("10.60.155.107:7000,10.60.155.107:7001,10.60.155.107:7002,10.60.155.108:7003,10.60.155.108:7004,10.60.155.108:7005");    
    String node;
    String lbAddress = "10.58.71.187:8686";

    static final String URI_CLEAR_CACHE = "/vtp/cachegw-ws/cache-clear";
    static final String URI_CLEAR_CACHE_WSDL = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><!-- Published by JAX-WS RI at http://jax-ws.dev.java.net. RI's version is JAX-WS RI 2.2.4-b01. --><!-- Generated by JAX-WS RI at http://jax-ws.dev.java.net. RI's version is JAX-WS RI 2.2.4-b01. --><definitions xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\" xmlns:wsp=\"http://www.w3.org/ns/ws-policy\" xmlns:wsp1_2=\"http://schemas.xmlsoap.org/ws/2004/09/policy\" xmlns:wsam=\"http://www.w3.org/2007/05/addressing/metadata\" xmlns:soap=\"http://schemas.xmlsoap.org/wsdl/soap/\" xmlns:tns=\"http://webservice.bccsgw.viettel.com/\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns=\"http://schemas.xmlsoap.org/wsdl/\" targetNamespace=\"http://webservice.bccsgw.viettel.com/\" name=\"BCCSGateway\">\n"
            + "    <types>\n"
            + "        <xsd:schema>\n"
            + "            <xsd:import namespace=\"http://webservice.bccsgw.viettel.com/\" schemaLocation=\"http://IP_PORT/vtp/cachegw-ws/cache-clear?xsd=1\"></xsd:import>\n"
            + "        </xsd:schema>\n"
            + "    </types>\n"
            + "    <message name=\"gwOperation\">\n"
            + "        <part name=\"Input\" type=\"tns:Input\"></part>\n"
            + "    </message>\n"
            + "    <message name=\"gwOperationResponse\">\n"
            + "        <part name=\"Result\" type=\"tns:Output\"></part>\n"
            + "    </message>\n"
            + "    <portType name=\"ServiceManagement\">\n"
            + "        <operation name=\"gwOperation\">\n"
            + "            <input wsam:Action=\"http://webservice.bccsgw.viettel.com/ServiceManagement/gwOperationRequest\" message=\"tns:gwOperation\"></input>\n"
            + "            <output wsam:Action=\"http://webservice.bccsgw.viettel.com/ServiceManagement/gwOperationResponse\" message=\"tns:gwOperationResponse\"></output>\n"
            + "        </operation>\n"
            + "    </portType>\n"
            + "    <binding name=\"BCCSGatewaySOAPBinding\" type=\"tns:ServiceManagement\">\n"
            + "        <soap:binding transport=\"http://schemas.xmlsoap.org/soap/http\" style=\"rpc\"></soap:binding>\n"
            + "        <operation name=\"gwOperation\">\n"
            + "            <soap:operation soapAction=\"\"></soap:operation>\n"
            + "            <input>\n"
            + "                <soap:body use=\"literal\" namespace=\"http://webservice.bccsgw.viettel.com/\"></soap:body>\n"
            + "            </input>\n"
            + "            <output>\n"
            + "                <soap:body use=\"literal\" namespace=\"http://webservice.bccsgw.viettel.com/\"></soap:body>\n"
            + "            </output>\n"
            + "        </operation>\n"
            + "    </binding>\n"
            + "    <service name=\"BCCSGateway\">\n"
            + "        <port name=\"BCCSGatewaySOAP\" binding=\"tns:BCCSGatewaySOAPBinding\">\n"
            + "            <soap:address location=\"http://IP_PORT/vtp/cachegw-ws/cache-clear\"></soap:address>\n"
            + "        </port>\n"
            + "    </service>\n"
            + "</definitions>";
    static final String URI_CLEAR_CACHE_XSD = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><!-- Published by JAX-WS RI at http://jax-ws.dev.java.net. RI's version is JAX-WS RI 2.2.4-b01. --><xs:schema xmlns:tns=\"http://webservice.bccsgw.viettel.com/\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" version=\"1.0\" targetNamespace=\"http://webservice.bccsgw.viettel.com/\">\n"
            + "    <xs:element name=\"Input\" type=\"tns:Input\"></xs:element>\n"
            + "    <xs:element name=\"Output\" type=\"tns:Output\"></xs:element>\n"
            + "    <xs:complexType name=\"Input\">\n"
            + "        <xs:sequence>\n"
            + "            <xs:element name=\"username\" type=\"xs:string\"></xs:element>\n"
            + "            <xs:element name=\"password\" type=\"xs:string\"></xs:element>\n"
            + "            <xs:element name=\"wscode\" type=\"xs:string\"></xs:element>\n"
            + "            <xs:element name=\"param\" type=\"tns:Param\" minOccurs=\"0\" maxOccurs=\"unbounded\"></xs:element>\n"
            + "            <xs:element name=\"rawData\" minOccurs=\"0\">\n"
            + "                <xs:simpleType>\n"
            + "                    <xs:restriction base=\"xs:string\"></xs:restriction>\n"
            + "                </xs:simpleType>\n"
            + "            </xs:element>\n"
            + "        </xs:sequence>\n"
            + "    </xs:complexType>\n"
            + "\n"
            + "    <xs:complexType name=\"Param\">\n"
            + "        <xs:sequence></xs:sequence>\n"
            + "        <xs:attribute name=\"name\" type=\"xs:string\"></xs:attribute>\n"
            + "        <xs:attribute name=\"value\" type=\"xs:string\"></xs:attribute>\n"
            + "    </xs:complexType>\n"
            + "\n"
            + "    <xs:complexType name=\"Output\">\n"
            + "        <xs:sequence>\n"
            + "            <xs:element name=\"error\" type=\"xs:string\"></xs:element>\n"
            + "            <xs:element name=\"description\" type=\"xs:string\"></xs:element>\n"
            + "            <xs:element name=\"return\" type=\"xs:string\" maxOccurs=\"unbounded\"></xs:element>\n"
            + "            <xs:element name=\"original\" type=\"xs:string\"></xs:element>\n"
            + "        </xs:sequence>\n"
            + "    </xs:complexType>\n"
            + "</xs:schema>";
    static final String URI_CLEAR_CACHE_RETURN = "<S:Envelope xmlns:S=\"http://schemas.xmlsoap.org/soap/envelope/\">\n"
            + "    <S:Body>\n"
            + "        <ns2:gwOperationResponse xmlns:ns2=\"http://webservice.bccsgw.viettel.com/\">\n"
            + "            <Result>\n"
            + "                <error>0</error>\n"
            + "                <description>success</description>\n"
            + "                <return>\n"
            + "                </return>\n"
            + "            </Result>\n"
            + "        </ns2:gwOperationResponse>\n"
            + "    </S:Body>\n"
            + "</S:Envelope>";

    public SoapGateway(String node, String conJedisCluster, String lbAddress) {
        this.node = node;
//        jedis = JedisUtil.getJedisCluster(conJedisCluster);
        this.lbAddress = lbAddress;
    }

    public static synchronized SoapGateway getInstance() {
        return singleton;
    }

    public static synchronized SoapGateway getInstance(String node, String conJedisCluster, String lbAddress) {
        if (singleton == null) {
            singleton = new SoapGateway(node, conJedisCluster, lbAddress);
        }
        return singleton;
    }

    private static Buffer postProcessWSDL(Buffer body, String contentType, String uri, String newUri) {
        logger.info("SoapGateway - postProcessWSDL() - Start");
        String charset = Utils.getEncoding(contentType, "UTF-8");
        String xml = body.toString(charset);
        StringBuilder sb = new StringBuilder(xml.length());
        Matcher m = LOCATION.matcher(xml);
        int start = 0;
        while (m.find()) {
            sb.append(xml, start, m.start(1)).append(newUri);
            start = m.end(1);
        }
        sb.append(xml, start, xml.length());
        logger.info("SoapGateway - postProcessWSDL() - End");
        return Buffer.buffer(sb.toString(), charset);
    }

    public static void process(HttpClient client, HttpService service, Endpoint endpoint, HttpServerRequestWrapper req,
            boolean debug) {
        String uri = endpoint.url() + req.getPath();
        String uriWithQuery = req.query() != null ? uri + "?" + req.query() : uri;
        long start = System.currentTimeMillis();

        Buffer reqBody = Buffer.buffer();
        Buffer respBuff = Buffer.buffer();

        HttpClientRequest cReq = client.requestAbs(req.method(), uriWithQuery, cResp -> {
            cResp.pause();
            HttpServerResponse resp = req.response();
            postResponse(cResp, resp);
            resp.setChunked(true);

            cResp.exceptionHandler(th -> {
                if (!req.response().ended()) {
                    Buffer buff = Buffer.buffer();
                    buff.appendString("Bad gateway");
                    resp.setStatusCode(502).end(buff.toString());

                    LogUtil.print(loggerIO, uriWithQuery, req.method().name(), start, System.currentTimeMillis() - start, 502, 0, 0, reqBody.toString(), buff.toString());
                }
            });

            cResp.handler(buff -> {
                resp.write(buff);
            });

            cResp.endHandler(v -> {
                long duration = System.currentTimeMillis() - start;
                resp.end();

                int statusCode = cResp.statusCode();
                int success;

                if (statusCode >= 200 && statusCode < 300) {
                    success = 1;
                } else {
                    success = 0;
                }

                LogUtil.print(loggerIO, uriWithQuery, req.method().name(), start, duration, statusCode, success, 0, reqBody.toString(), respBuff.toString());
            });

            cResp.resume();
        });

        preRequest(req, cReq, endpoint);
        cReq.setChunked(true);

        req.handler(buff -> {
            reqBody.appendBuffer(buff);
            cReq.write(buff);
        });

        req.endHandler(v -> {
            cReq.end();
            if (service.params() != null) {
                KxmlSoapExtractor.INSTANCE.extract(service.params(), reqBody.toString(req.getCharset()), req);
            }
        });

        long timeout = service.timeout();
        Handler<Throwable> handler = (th) -> {
            if (!req.response().ended()) {
                List<String> alertReceivers = service.alertReceivers();
                if (alertReceivers != null) {

                }

                if (th instanceof TimeoutException) {
                    req.response().setStatusCode(504).end("Proxy Timeout");
                } else {
                    req.response().setStatusCode(502).end("Bad gateway");
                }
            }
        };

        if (timeout > 0) {
            HttpClientHelper.setTimeout(cReq, timeout, handler);
        } else {
            cReq.exceptionHandler(handler);
        }

        req.resume();
    }

    /**
     * Ham: thuc hien giao thuc POST cua proxy SOAP Gateway client: http request
     * cua proxy se gui thong tin den may chu dich endpoint: thong tin cua may
     * chu proxy req: http request cua client gui toi proxy body: noi dung cua
     * http trong request tu client gui den debug:
     *
     * @param client
     * @param endpoint
     * @param req
     * @param body
     * @param debug
     */
    public void process(
            HttpClient client,
            //HttpService service,
            Endpoint endpoint,
            HttpServerRequestWrapper req,
            Buffer body,
            boolean debug) {
        logger.info("SoapGateway - process() - Start - AccessId: {}", req.getAccessId());

        //String uri = endpoint.url() + req.getPath();
        String uri = endpoint.url();
        String uriWithQuery = req.query() != null ? uri + "?" + req.query() : uri;
        long start = System.currentTimeMillis();

        Buffer bodyResp = Buffer.buffer();

        if (uriWithQuery.contains(URI_CLEAR_CACHE)) {
            HttpServerResponse resp = req.response();
            resp.setChunked(true);
            resp.write(URI_CLEAR_CACHE_RETURN);
            resp.end();

            JsonObject message = new JsonObject();
            message.put("uri", uri);
            message.put("request", body.toString());
            Utils.send2Process(endpoint.node() + "-" + CACHE_EVENT_BUS_CHANNEL_CLEAR, message.toString(), req.getVertx());

            LogUtil.transaction(loggerIO, uriWithQuery, req.method().name(), req.getTargetService(), start, System.currentTimeMillis() - start, resp.getStatusCode(), 1, req.getAccessId(), body.toString(), bodyResp.toString());
            LogUtil.transaction(loggerGWIO, uriWithQuery, req.method().name(), req.getTargetService(), req.getStartTime(), System.currentTimeMillis() - req.getStartTime(), resp.getStatusCode(), 1, req.getAccessId(), body.toString(), bodyResp.toString());
            return;
        }

        // Kiem tra du lieu da co trong redis chua
        // neu co roi thi thuc hien lay trong cache ra
        // chi can anh xa body sang response boi vi code
        // tren cac may chu co cung ma nguon nen request body se giong nhau neu cung doi tuong?!!!
        // tuy nhien body co cac ky tu dac biet can luu y
        // => Da chuyen base64 de khong con ky tu dac biet
        String s;
        s = body.toString();
//        s = JedisUtil.getKeyBase64(jedis, s, null);
//        if (s != null) {
//            HttpServerResponse resp = req.response();
//            resp.setChunked(true);
//            //resp.setStatusCode(200).end("OK");
//            resp.write(s);
//            resp.end();
//
//            LogUtil.transaction(loggerIO, uriWithQuery, req.method().name(), req.getTargetService(), start, System.currentTimeMillis() - start, resp.getStatusCode(), 1, req.getAccessId(), body.toString(), bodyResp.toString());
//            LogUtil.transaction(loggerGWIO, uriWithQuery, req.method().name(), req.getTargetService(), req.getStartTime(), System.currentTimeMillis() - req.getStartTime(), resp.getStatusCode(), 1, req.getAccessId(), body.toString(), bodyResp.toString());
//            return;
//        }

        // trong truong hop chua co trong cache
        // tien hanh gui request den may dich de lay thong tin ...        
        HttpClientRequest cReq = client.requestAbs(req.method(), uriWithQuery, cResp -> {
            cResp.pause();
            HttpServerResponse resp = req.response();

            // thuc hien sao chep headers tu response den may
            postResponse(cResp, resp);
            resp.setChunked(true);

            cResp.exceptionHandler(th -> {
                if (!req.response().ended()) {
                    Buffer buff = Buffer.buffer();
                    buff.appendString("Bad gateway");
                    resp.setStatusCode(502).end(buff.toString());

                    LogUtil.transaction(loggerIO, uriWithQuery, req.method().name(), req.getTargetService(), start, System.currentTimeMillis() - start, 502, 0, req.getAccessId(), body.toString(), bodyResp.toString());
                    LogUtil.transaction(loggerGWIO, uriWithQuery, req.method().name(), req.getTargetService(), req.getStartTime(), System.currentTimeMillis() - req.getStartTime(), 502, 0, req.getAccessId(), body.toString(), bodyResp.toString());
//                    LogUtil.print(loggerIO, uriWithQuery, req.method().name(), start, System.currentTimeMillis() - start, 502, 0, 0, body.toString(), buff.toString());
                }
            });

            // lay thong tin reponse tu may dich            
            {
                cResp.handler(buff -> {
                    bodyResp.appendBuffer(buff);
                    resp.write(buff);
                });

                cResp.endHandler(v -> {
                    long duration = System.currentTimeMillis() - start;
                    resp.end();

                    // Can phan tich noi dung body de lay thoi gian luu du lieu tren bo dem
                    // theo web service va ham cua web service
                    // ???
                    //JedisUtil.setKeyBase64(jedis, body.toString(), bodyResp.toString(), 600);
                    // dong doi du lieu de thuc hien phan tich xu ly luu tru o luong khac
                    // toi uu hoa hoat dong cua CacheGW
                    JsonObject message = new JsonObject();
                    message.put("uri", uri);
                    message.put("request", body.toString());
                    message.put("response", bodyResp.toString());
                    //jedis.publish(CACHE_SOAP_JEDIS_CHANNEL_1, message.toString());
                    Utils.send2Process(endpoint.node() + "-" + CACHE_EVENT_BUS_CHANNEL_SOAP, message.toString(), req.getVertx());

//                    String TransactionCode = req.getParam("transaction");
                    LogUtil.transaction(loggerIO, uriWithQuery, req.method().name(), req.getTargetService(), start, duration, resp.getStatusCode(), 1, req.getAccessId(), body.toString(), bodyResp.toString());
                    LogUtil.transaction(loggerGWIO, uriWithQuery, req.method().name(), req.getTargetService(), req.getStartTime(), System.currentTimeMillis() - req.getStartTime(), resp.getStatusCode(), 1, req.getAccessId(), body.toString(), bodyResp.toString());
                    boolean check;

                    // thuc hien luu cache thong tin tu diem nay vao redis cluster
                    int statusCode = cResp.statusCode();
                    if (check = (statusCode >= 200 && statusCode < 300)) {

                    } else {

                    }
                });
            }
            cResp.resume();
        });

        cReq.exceptionHandler(th -> {
            if (!req.response().ended()) {
                Buffer buff = Buffer.buffer();
                buff.appendString("Bad gateway");
                req.response().setStatusCode(502).end(buff.toString());
                long duration = System.currentTimeMillis() - start;
//                LogUtil.print(loggerIO, uriWithQuery, req.method().name(), start, System.currentTimeMillis() - start, 502, 0, 0, body.toString(), buff.toString());
                LogUtil.transaction(loggerIO, uriWithQuery, req.method().name(), req.getTargetService(), start, duration, 502, 0, req.getAccessId(), body.toString(), bodyResp.toString());
                LogUtil.transaction(loggerGWIO, uriWithQuery, req.method().name(), req.getTargetService(), req.getStartTime(), System.currentTimeMillis() - req.getStartTime(), 502, 0, req.getAccessId(), body.toString(), bodyResp.toString());
            }
        });

        preRequest(req, cReq, endpoint);
        long timeout = 60000;
        Handler<Throwable> handler = (th) -> {
            Buffer buff = Buffer.buffer();
            int code;

            if (!req.response().ended()) {
                req.out(start, System.currentTimeMillis() - start, req.method().name(), uriWithQuery,
                        "fail to request external service", th);
                if (th instanceof TimeoutException) {
                    buff.appendString("Proxy Timeout");
                    code = 504;
                } else {
                    code = 502;
                    buff.appendString("Bad gateway");
                }

                req.response().setStatusCode(code).end(buff.toString());
//                LogUtil.print(loggerIO, uriWithQuery, req.method().name(), start, System.currentTimeMillis() - start, code, 0, 0, body.toString(), buff.toString());
                LogUtil.transaction(loggerIO, uriWithQuery, req.method().name(), req.getTargetService(), start, System.currentTimeMillis() - start, code, 0, req.getAccessId(), body.toString(), bodyResp.toString());
                LogUtil.transaction(loggerGWIO, uriWithQuery, req.method().name(), req.getTargetService(), req.getStartTime(), System.currentTimeMillis() - req.getStartTime(), code, 0, req.getAccessId(), body.toString(), bodyResp.toString());
            }
        };

        if (timeout > 0) {
            HttpClientHelper.setTimeout(cReq, timeout, handler);
        } else {
            cReq.exceptionHandler(handler);
        }

//        if (timeout > 0) {
//          cReq.setTimeout(timeout);
//        }
        logger.info("SoapGateway - process() - End - AccessId: {}", req.getAccessId());
        cReq.end(body);
    }

    public static void process(HttpClient client, HttpService service, Endpoint endpoint, HttpServerRequestWrapper req,
            Future<Buffer> body, boolean debug) {

        String uri = endpoint.url() + req.getPath();
        String uriWithQuery = req.query() != null ? uri + "?" + req.query() : uri;
        long start = System.currentTimeMillis();
        HttpClientRequest cReq = client.requestAbs(req.method(), uriWithQuery, cResp -> {
            cResp.pause();
            HttpServerResponse resp = req.response();
            postResponse(cResp, resp);
            resp.setChunked(true);
            cResp.exceptionHandler(th -> {
                if (!req.response().ended()) {
                    resp.setStatusCode(502).end("Bad gateway");
                    req.out(start, System.currentTimeMillis() - start, req.method().name(), uriWithQuery,
                            "fail to get response from external service", th);
                }
            });
            Map<String, String> respParams = service.respParams();
            if (debug || respParams != null) {
                Buffer respBuff = Buffer.buffer();
                cResp.handler(buff -> {
                    respBuff.appendBuffer(buff);
                    resp.write(buff);
                });
                cResp.endHandler(v -> {
                    long duration = System.currentTimeMillis() - start;
                    resp.end();
                    boolean check;
                    int statusCode = cResp.statusCode();
                    if (statusCode >= 200 && statusCode < 300) {
                        String contentAsString = respBuff.toString(StandardCharsets.UTF_8);
                        KxmlSoapExtractor.INSTANCE.extractResponse(respParams, contentAsString, req);
                        if (debug) {
                            try {
                                String respJson = req.getRespParams();
                                req.setRespParams((respJson != null && !respJson.isEmpty() ? ",\"raw\":\"" : "\"raw\":\"")
                                        + StringEscapeUtils.escapeJava(contentAsString) + '"');
                            } catch (Exception e) {
                                logger.error("Can not escape {}", contentAsString, e);
                            }
                        }
                        check = !service.check() || service.check(contentAsString);

                    } else {
                        check = false;

                    }
                    req.out(start, duration, req.method().name(), uriWithQuery, cResp.statusCode(), cResp.statusMessage(), check);
                    if (duration > service.standardDuration()) {
                        List<String> alertReceivers = service.alertReceivers();
                        if (alertReceivers != null) {

                        }
                    }
                });
            } else {
                cResp.handler(buff -> {
                    resp.write(buff);
                });
                cResp.endHandler(v -> {
                    long duration = System.currentTimeMillis() - start;
                    resp.end();
                    boolean check;
                    int statusCode = cResp.statusCode();
                    if (check = (statusCode >= 200 && statusCode < 300)) {

                    } else {

                    }
                    req.out(start, duration, req.method().name(), uriWithQuery, cResp.statusCode(), cResp.statusMessage(), check);
                    if (duration > service.standardDuration()) {
                        List<String> alertReceivers = service.alertReceivers();
                        if (alertReceivers != null) {

                        }
                    }

                });
            }
            cResp.resume();
        });
        preRequest(req, cReq, endpoint);
        cReq.setChunked(true);
        cReq.sendHead();
        body.setHandler(bodyResult -> {
            if (bodyResult.succeeded()) {
                long timeout = service.timeout();
                if (timeout > 0) {
                    cReq.setTimeout(timeout);
                }
                cReq.end(bodyResult.result());

                Handler<Throwable> handler = (th) -> {
                    if (!req.response().ended()) {
                        List<String> alertReceivers = service.alertReceivers();
                        if (alertReceivers != null) {

                        }

                        req.out(start, System.currentTimeMillis() - start, req.method().name(), uriWithQuery,
                                "fail to request external service", th);
                        if (th instanceof TimeoutException) {
                            req.response().setStatusCode(504).end("Proxy Timeout");
                        } else {
                            req.response().setStatusCode(502).end("Bad gateway");
                        }

                    }
                };
                if (timeout > 0) {
                    HttpClientHelper.setTimeout(cReq, timeout, handler);
                } else {
                    cReq.exceptionHandler(handler);
                }
                //TODO check

            } else {
                cReq.setTimeout(1);
                req.response().setStatusCode(400).end("Bad request");
            }
        });
    }

    /**
     * Ham: thuc hien chuc nang GET cua proxy voi viec thuc hien http request
     * toi dia chi uri va http request cua client da cho client: http request
     * cua proxy uri: dia chi uri dich can truy nhap req: http request cua
     * client toi proxy
     *
     * @param client
     * @param uri
     * @param endpoint
     * @param req
     */
    public void processSchema(
            HttpClient client,
            String uri,
            Endpoint endpoint,
            HttpServerRequestWrapper req) {
        logger.info("SoapGateway - processSchema() - Start - AccessId: {}", req.getAccessId());
        String uriWithQuery = uri;
        long start = System.currentTimeMillis();

        // thuc hien kiem tra cache da luu thong tin request chua
        // neu co roi thi lay truc tiep tu trong cache ra
        Vertx vertx = req.getVertx();
        String body = Utils.getSchema(vertx, uri);

        // kiem tra URI cho xoa cache?        
        if (uri.contains(URI_CLEAR_CACHE)) {
            if (uri.contains("?wsdl")) {
                body = URI_CLEAR_CACHE_WSDL;
            } else if (uri.contains("?xsd=1")) {
                body = URI_CLEAR_CACHE_XSD;
            } else {
                body = "clear cache not supported";
            }
            body = body.replaceAll("IP_PORT", lbAddress);
        }

        if (body != null) {
            HttpServerResponse resp = req.response();
            resp.end(body);
        }

        // nen luu truc tiep trong bo nho may ???        
        // trong truong hop chua co thong tin trong cache
        // thi lay truc tiep thong tin may chu dich ...        
        HttpClientRequest cReq = client.requestAbs(req.method(), uriWithQuery, cResp -> {
            HttpServerResponse resp = req.response();
            postResponse(cResp, resp);
            cResp.exceptionHandler(th -> {
                if (!req.response().ended()) {
                    resp.setStatusCode(502).end("Bad gateway");
                }
            });

            cResp.bodyHandler(buff -> {
                if (cResp.statusCode() == 200) {

                } else {

                }

                long duration = System.currentTimeMillis() - start;

                if ("wsdl".equals(req.query())) {
                    buff = postProcessWSDL(buff, cResp.getHeader(HttpHeaders.CONTENT_TYPE), uri, req.getContext());
                    resp.putHeader(HttpHeaders.CONTENT_LENGTH, String.valueOf(buff.length()));
                }

                // luu tru noi dung schema vao trong cache
                Utils.updateSchema(vertx, uri, buff.toString());

                resp.end(buff);
            });

        });

        cReq.exceptionHandler(th -> {
            if (!req.response().ended()) {
                req.response().setStatusCode(502).end("Bad gateway");
            }
        });

//        // thong tin xac thuc lay trong cau hinh app
//        DefaultEndpoint endpoint = new DefaultEndpoint();
//        
//        //endpoint.setAuthorization("Basic dnRwOnBhc3N3b3Jk");
//        endpoint.setAuthorization(req.getAuthorization());
//        
//        endpoint.setUrl(uri);
//        endpoint.setActivated(true);
//        endpoint.setHost("10.61.100.108");   // IP cua may chu thuc hien request
//        endpoint.setNode(node);
        preRequest(req, cReq, endpoint);
        cReq.setTimeout(60000);             // thoi gian timeout phai lay trong cau hinh cua vtpgw?
        logger.info("SoapGateway - processSchema() - End - AccessId: {}", req.getAccessId());
        cReq.end();
    }
}
